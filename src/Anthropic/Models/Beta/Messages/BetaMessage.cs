using System.Collections.Frozen;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;
using Anthropic.Core;
using Anthropic.Exceptions;
using Anthropic.Models.Messages;

namespace Anthropic.Models.Beta.Messages;

[JsonConverter(typeof(JsonModelConverter<BetaMessage, BetaMessageFromRaw>))]
public sealed record class BetaMessage : JsonModel
{
    /// <summary>
    /// Unique object identifier.
    ///
    /// <para>The format and length of IDs may change over time.</para>
    /// </summary>
    public required string ID
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNotNullClass<string>("id");
        }
        init { this._rawData.Set("id", value); }
    }

    /// <summary>
    /// Information about the container used in the request (for the code execution tool)
    /// </summary>
    public required BetaContainer? Container
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNullableClass<BetaContainer>("container");
        }
        init { this._rawData.Set("container", value); }
    }

    /// <summary>
    /// Content generated by the model.
    ///
    /// <para>This is an array of content blocks, each of which has a `type` that
    /// determines its shape.</para>
    ///
    /// <para>Example:</para>
    ///
    /// <para>```json [{"type": "text", "text": "Hi, I'm Claude."}] ```</para>
    ///
    /// <para>If the request input `messages` ended with an `assistant` turn, then
    /// the response `content` will continue directly from that last turn. You can
    /// use this to constrain the model's output.</para>
    ///
    /// <para>For example, if the input `messages` were: ```json [   {"role": "user",
    /// "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///   {"role": "assistant", "content": "The best answer is ("} ] ```</para>
    ///
    /// <para>Then the response `content` might be:</para>
    ///
    /// <para>```json [{"type": "text", "text": "B)"}] ```</para>
    /// </summary>
    public required IReadOnlyList<BetaContentBlock> Content
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNotNullStruct<ImmutableArray<BetaContentBlock>>("content");
        }
        init
        {
            this._rawData.Set<ImmutableArray<BetaContentBlock>>(
                "content",
                ImmutableArray.ToImmutableArray(value)
            );
        }
    }

    /// <summary>
    /// Context management response.
    ///
    /// <para>Information about context management strategies applied during the request.</para>
    /// </summary>
    public required BetaContextManagementResponse? ContextManagement
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNullableClass<BetaContextManagementResponse>(
                "context_management"
            );
        }
        init { this._rawData.Set("context_management", value); }
    }

    /// <summary>
    /// The model that will complete your prompt.\n\nSee [models](https://docs.anthropic.com/en/docs/models-overview)
    /// for additional details and options.
    /// </summary>
    public required ApiEnum<string, Model> Model
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNotNullClass<ApiEnum<string, Model>>("model");
        }
        init { this._rawData.Set("model", value); }
    }

    /// <summary>
    /// Conversational role of the generated message.
    ///
    /// <para>This will always be `"assistant"`.</para>
    /// </summary>
    public JsonElement Role
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNotNullStruct<JsonElement>("role");
        }
        init { this._rawData.Set("role", value); }
    }

    /// <summary>
    /// The reason that we stopped.
    ///
    /// <para>This may be one the following values: * `"end_turn"`: the model reached
    /// a natural stopping point * `"max_tokens"`: we exceeded the requested `max_tokens`
    /// or the model's maximum * `"stop_sequence"`: one of your provided custom `stop_sequences`
    /// was generated * `"tool_use"`: the model invoked one or more tools * `"pause_turn"`:
    /// we paused a long-running turn. You may provide the response back as-is in
    /// a subsequent request to let the model continue. * `"refusal"`: when streaming
    /// classifiers intervene to handle potential policy violations</para>
    ///
    /// <para>In non-streaming mode this value is always non-null. In streaming mode,
    /// it is null in the `message_start` event and non-null otherwise.</para>
    /// </summary>
    public required ApiEnum<string, BetaStopReason>? StopReason
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNullableClass<ApiEnum<string, BetaStopReason>>("stop_reason");
        }
        init { this._rawData.Set("stop_reason", value); }
    }

    /// <summary>
    /// Which custom stop sequence was generated, if any.
    ///
    /// <para>This value will be a non-null string if one of your custom stop sequences
    /// was generated.</para>
    /// </summary>
    public required string? StopSequence
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNullableClass<string>("stop_sequence");
        }
        init { this._rawData.Set("stop_sequence", value); }
    }

    /// <summary>
    /// Object type.
    ///
    /// <para>For Messages, this is always `"message"`.</para>
    /// </summary>
    public JsonElement Type
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNotNullStruct<JsonElement>("type");
        }
        init { this._rawData.Set("type", value); }
    }

    /// <summary>
    /// Billing and rate-limit usage.
    ///
    /// <para>Anthropic's API bills and rate-limits by token counts, as tokens represent
    /// the underlying cost to our systems.</para>
    ///
    /// <para>Under the hood, the API transforms requests into a format suitable for
    /// the model. The model's output then goes through a parsing stage before becoming
    /// an API response. As a result, the token counts in `usage` will not match one-to-one
    /// with the exact visible content of an API request or response.</para>
    ///
    /// <para>For example, `output_tokens` will be non-zero, even for an empty string
    /// response from Claude.</para>
    ///
    /// <para>Total input tokens in a request is the summation of `input_tokens`,
    /// `cache_creation_input_tokens`, and `cache_read_input_tokens`.</para>
    /// </summary>
    public required BetaUsage Usage
    {
        get
        {
            this._rawData.Freeze();
            return this._rawData.GetNotNullClass<BetaUsage>("usage");
        }
        init { this._rawData.Set("usage", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.Container?.Validate();
        foreach (var item in this.Content)
        {
            item.Validate();
        }
        this.ContextManagement?.Validate();
        this.Model.Validate();
        if (!JsonElement.DeepEquals(this.Role, JsonSerializer.SerializeToElement("assistant")))
        {
            throw new AnthropicInvalidDataException("Invalid value given for constant");
        }
        this.StopReason?.Validate();
        _ = this.StopSequence;
        if (!JsonElement.DeepEquals(this.Type, JsonSerializer.SerializeToElement("message")))
        {
            throw new AnthropicInvalidDataException("Invalid value given for constant");
        }
        this.Usage.Validate();
    }

    public BetaMessage()
    {
        this.Role = JsonSerializer.SerializeToElement("assistant");
        this.Type = JsonSerializer.SerializeToElement("message");
    }

    public BetaMessage(BetaMessage betaMessage)
        : base(betaMessage) { }

    public BetaMessage(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = new(rawData);

        this.Role = JsonSerializer.SerializeToElement("assistant");
        this.Type = JsonSerializer.SerializeToElement("message");
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BetaMessage(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = new(rawData);
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BetaMessageFromRaw.FromRawUnchecked"/>
    public static BetaMessage FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BetaMessageFromRaw : IFromRawJson<BetaMessage>
{
    /// <inheritdoc/>
    public BetaMessage FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        BetaMessage.FromRawUnchecked(rawData);
}
